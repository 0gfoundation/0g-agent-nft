// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./base/BaseVerifier.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

enum VerifierType {
    TEE,
    ZKP
}

contract Verifier is
    BaseVerifier,
    Initializable,
    AccessControlUpgradeable,
    PausableUpgradeable
{
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;
    
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    address public attestationContract;
    VerifierType public verifierType;

    uint256 public maxProofAge;

    string public constant VERSION = "2.0.0";

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address _attestationContract,
        VerifierType _verifierType,
        address _admin
    ) external initializer {
        __AccessControl_init();
        __Pausable_init();

        attestationContract = _attestationContract;
        verifierType = _verifierType;
        maxProofAge = 7 days;

        _grantRole(DEFAULT_ADMIN_ROLE, _admin);
        _grantRole(ADMIN_ROLE, _admin);
        _grantRole(PAUSER_ROLE, _admin);
    }

    function updateAttestationContract(
        address _attestationContract
    ) external onlyRole(ADMIN_ROLE) {
        attestationContract = _attestationContract;
    }

    function updateMaxProofAge(
        uint256 _maxProofAge
    ) external onlyRole(ADMIN_ROLE) {
        maxProofAge = _maxProofAge;
    }

    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    function hashNonce(bytes memory nonce) private pure returns (bytes32) {
        return keccak256(nonce);
    }

    function _mockTeeVerifierVerify(
        bytes32 dataHash,
        bytes memory signature
    ) internal pure returns (bool) {
        return true;
    }

    /// @notice Verify preimage of data, the _proof prove:
    ///         for public data, the proof is knowing the pre-image of dataHashes
    ///         for private data, the proof is knowing the pre-image of dataHashes and the plaintext of the pre-image
    ///         if preimage proof is not required, the proof is the data itself âœ…
    /// @param proofs Proof generated by TEE
    function verifyPreimage(
        bytes[] calldata proofs
    ) external pure override returns (PreimageProofOutput[] memory) {
        PreimageProofOutput[] memory outputs = new PreimageProofOutput[](
            proofs.length
        );
        for (uint256 i = 0; i < proofs.length; i++) {
            require(proofs[i].length == 32, "Invalid data hash length");
            bytes32 dataHash = bytes32(proofs[i]);

            bool isValid = true;

            outputs[i] = PreimageProofOutput(dataHash, isValid);
        }
        return outputs;
    }

    /// @notice Extract and verify signature from the accessibility proof
    /// @param accessibilityProof The signature proof
    /// @param isPrivate Whether the data is private
    /// @param newDataHash The hash of the new data
    /// @param oldDataHash The hash of the old data (for private data only)
    /// @return The recovered signer address
    function verifyAccessibility(
        bytes memory accessibilityProof,
        bool isPrivate,
        bytes memory nonce,
        bytes32 newDataHash,
        bytes32 oldDataHash
    ) private pure returns (address) {
        require(
            accessibilityProof.length == 65,
            "Invalid accessibility proof length"
        );

        bytes32 messageHash = createMessageHash(
            isPrivate,
            newDataHash,
            oldDataHash,
            nonce
        );
        
        return messageHash.recover(accessibilityProof);
    }

    function verfifyOwnershipProof(
        bytes memory ownershipProof,
        bytes memory nonce,
        bytes32 newDataHash,
        bytes32 oldDataHash,
        bytes16 sealedKey,
        address receiver,
        bool isTEE
    ) private pure returns (bool) {
        if (isTEE) {
            bytes32 ownershipHashHex = keccak256(
                abi.encodePacked(nonce, newDataHash, oldDataHash, sealedKey, receiver)
            );

            string memory message = Strings.toHexString(
                uint256(ownershipHashHex),
                32
            );
            bytes32 ethSignedHash = keccak256(
                abi.encodePacked("\x19Ethereum Signed Message:\n66", message)
            );

            return _mockTeeVerifierVerify(ethSignedHash, ownershipProof);
        } else {
            return true;
        }
    }

    /// @notice Create the message hash for signature verification
    /// @param isPrivate Whether the data is private
    /// @param newDataHash The hash of the new data
    /// @param oldDataHash The hash of the old data (for private data only)
    /// @return The message hash
    function createMessageHash(
        bool isPrivate,
        bytes32 newDataHash,
        bytes32 oldDataHash,
        bytes memory nonce
    ) private pure returns (bytes32) {
        bytes32 messageHex;
        if (isPrivate) {
            messageHex = keccak256(
                abi.encodePacked(newDataHash, oldDataHash, nonce)
            );
        } else {
            messageHex = keccak256(abi.encodePacked(newDataHash, nonce));
        }
        string memory message = Strings.toHexString(uint256(messageHex), 32);
        return
            keccak256(
                abi.encodePacked("\x19Ethereum Signed Message:\n66", message)
            );
    }

    /// @notice Process a single transfer validity proof
    /// @param proof The proof data
    /// @return output The processed proof data as a struct
    function processTransferProof(
        bytes calldata proof
    ) private view returns (TransferValidityProofOutput memory output) {
        // Parse the indicator
        bool isTEE = (uint8(proof[0]) & 0x80) == 0;
        require(
            isTEE == (verifierType == VerifierType.TEE),
            "Incorrect verifier type"
        );

        bool isPrivate = (uint8(proof[0]) & 0x40) != 0;

        // Extract accessibility proof
        bytes memory accessibilityProof = proof[1:66];

        // Extract nonce for accessibility proof
        bytes memory accessProofNonce = proof[66:114];

        // Extract hashes
        output.newDataHash = bytes32(proof[114:146]);

        if (isPrivate) {
            output.oldDataHash = bytes32(proof[194:226]);
            output.sealedKey = bytes16(proof[226:242]);
        }

        output.realAccessor = verifyAccessibility(
            accessibilityProof,
            isPrivate,
            accessProofNonce,
            output.newDataHash,
            output.oldDataHash
        );
        
        require(output.realAccessor != address(0), "Invalid real accessor");

        bool isValid = true;

        if (isPrivate) {
            bytes memory ownershipProofNonce = proof[146:194];
            address receiver = address(bytes20(proof[242:252]));
            output.receiver = receiver;
            bytes memory ownershipProof = proof[252:];
            isValid = verfifyOwnershipProof(
                ownershipProof,
                ownershipProofNonce,
                output.newDataHash,
                output.oldDataHash,
                output.sealedKey,
                receiver,
                isTEE
            );
            // verify ownership proof
            // remember to verify the key to encrypt the sealedKey is receiver's pubKey
            // verifyOwnershipProof(ownershipProof, isTEE, output.newDataHash, output.oldDataHash, output.sealedKey);
        }

        output.isValid = isValid;
        return output;
    }

    /// @notice Verify data transfer validity, the _proof prove:
    ///         1. The pre-image of oldDataHashes
    ///         2. The oldKey can decrypt the pre-image and the new key re-encrypt the plaintexts to new ciphertexts
    ///         3. The newKey is encrypted with the receiver's pubKey to get the sealedKey
    ///         4. The hashes of new ciphertexts is newDataHashes (key to note: TEE could support a private key of the receiver)
    ///         5. The newDataHashes identified ciphertexts are available in the storage: need the signature from the receiver signing oldDataHashes and newDataHashes
    /// @param proofs Proof generated by TEE
    /// The first 1 bit is the proof type, 0 for TEE, 1 for ZKP
    /// The second 1 bit is the proof type, 0 for public data, 1 for private data
    /// The 2~7 bits are reserved for future use
    /// The 1~65 bytes are the accessibility proof
    /// The 66~113 bytes are the access proof nonce
    /// The 114~145 bytes are the newDataHashes
    /// If private data, 146~193 bytes are the ownership proof nonce
    /// If private data, 194~225 bytes are the oldDataHashes
    /// If private data, 226~241 bytes are the sealedKey,
    /// If private data, 242~251 bytes are the receiver's address
    /// If private data, the rest of the proof from the oracle
    function verifyTransferValidity(
        bytes[] calldata proofs
    )
        public
        virtual
        override
        whenNotPaused
        returns (TransferValidityProofOutput[] memory)
    {
        TransferValidityProofOutput[]
            memory outputs = new TransferValidityProofOutput[](proofs.length);

        for (uint256 i = 0; i < proofs.length; i++) {
            TransferValidityProofOutput memory output = processTransferProof(
                proofs[i]
            );

            // Create the output
            outputs[i] = output;

            bytes32 accessProofNonce = hashNonce(proofs[i][66:114]);
            _checkAndMarkProof(accessProofNonce);

            bool isPrivate = (uint8(proofs[i][0]) & 0x40) != 0; 
            if (isPrivate) {
                bytes32 ownershipProofNonce = hashNonce(proofs[i][146:194]);
                _checkAndMarkProof(ownershipProofNonce);
            }
        }

        return outputs;
    }

    uint256[50] private __gap;
}
